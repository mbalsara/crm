# CRM Codebase Coding Practices

This file contains coding practices and conventions learned from development interactions. Follow these guidelines to maintain consistency and avoid common mistakes.

## ⚠️ CRITICAL RULES (Always Apply)

1. **ALWAYS use timeouts for ALL command executions** - See "Command Execution" section below. This prevents infinite hangs and is mandatory for every command.

## Package Organization

### Shared Package (`packages/shared`)
- **DO**: Export only truly shared types, utilities, and services
- **DON'T**: Put API-specific conversion utilities or business logic here
- **DON'T**: Export database schemas directly - use API-specific exports instead
- **Example**: Email types (`Email`, `EmailThread`) belong in shared, but converters (`emailToDb`, `threadToDb`) belong in API

### Database Package (`packages/database`)
- **DO**: Only export db instance, Database type, and repository classes
- **DON'T**: Store schemas here - schemas are API-specific
- **DON'T**: Re-export types from API schemas - types should be imported directly from API modules
- **DO**: Import schemas from API modules for drizzle initialization
- **Rationale**: 
  - Schemas define API's database structure, not shared infrastructure
  - Types should be imported directly from where they're defined (API modules)
  - Database package is infrastructure layer, not a type export layer

### API Package (`apps/api`)
- **DO**: Create app-specific schema exports that control what's exposed
- **DO**: Keep conversion utilities API-specific (not in shared)
- **DO**: Validate incoming data using Zod schemas at API boundaries

## Naming Conventions

### File Names
- **DO**: Use kebab-case for TypeScript files: `email-threads.ts`, `email-parser.ts`
- **DON'T**: Use snake_case: `email_threads.ts` (reserved for SQL/database)
- **Note**: Database table names use snake_case (`email_threads`), but TypeScript files use kebab-case

### Type Names
- **DO**: Use simple, clear names: `Email`, `EmailThread`, `EmailCollection`
- **DON'T**: Add unnecessary prefixes like "Normalized" when internal DB objects aren't exposed
- **Rationale**: If only shared types are exposed externally, simpler names are clearer

### Function Names
- **DO**: Use descriptive names: `emailToDb`, `threadToDb`
- **DON'T**: Use verbose names: `normalizedEmailToDatabaseInsertType`

## Data Validation

### Use Zod Schemas for External Objects
- **DO**: Define ALL external-facing types (API requests, responses, client interfaces) as Zod schemas
- **DO**: Export Zod schemas from client packages so APIs can validate incoming data
- **DO**: Use `z.infer<typeof schema>` to derive TypeScript types from Zod schemas
- **DO**: Validate at API boundaries (route handlers) using the exported Zod schemas
- **DO**: Use `z.coerce.date()` for date fields to handle both Date objects and ISO strings
- **Example**:
  ```typescript
  // In packages/clients/src/company/client.ts
  export const createCompanyRequestSchema = z.object({
    tenantId: z.string().uuid(),
    domain: z.string().min(1).max(255),
    domainType: z.enum(['business', 'personal', 'excluded']).optional().default('business'),
    // ...
  });
  export type CreateCompanyRequest = z.infer<typeof createCompanyRequestSchema>;
  
  // In apps/api/src/companies/routes.ts
  import { createCompanyRequestSchema } from '@crm/clients';
  const validated = createCompanyRequestSchema.parse(body);
  ```

### Validation Strategy
- **DO**: Define Zod schemas in client packages for all request/response types
- **DO**: Import and use these schemas in API route handlers for validation
- **DO**: Validate incoming API requests using Zod schemas at route boundaries
- **DO**: Fail fast with clear error messages
- **DO**: Return validation errors with details to help debugging
- **DON'T**: Use plain TypeScript interfaces for external-facing types - always use Zod schemas

## Database Schema Design

### Avoid Redundancy
- **DO**: Derive provider from `integration_id` via joins
- **DON'T**: Store `provider` column in `email_threads` table when `integration_id` exists
- **Rationale**: `integration_id` → `integrations.source` provides the provider, avoiding data duplication

### Foreign Keys
- **DO**: Use proper foreign key relationships
- **DO**: Use `ON DELETE CASCADE` where appropriate (e.g., emails → threads)
- **DO**: Make foreign keys NOT NULL when they're required

### Unique Constraints
- **DO**: Use composite unique constraints: `(tenant_id, integration_id, provider_thread_id)`
- **DON'T**: Include redundant columns in unique constraints

## Code Organization

### Conversion Utilities
- **DO**: Keep conversion utilities in the consuming app (e.g., `apps/api/src/emails/converter.ts`)
- **DON'T**: Put conversion utilities in shared packages
- **Rationale**: Conversions are API-specific and shouldn't pollute shared code

### Schema Organization
- **DO**: Co-locate schemas with their related code in module folders
- **DO**: Store schemas in `apps/api/src/{module}/schema.ts` alongside repository, service, routes
- **DO**: Import schemas from module folders, not a central location
- **Example**:
  ```typescript
  // apps/api/src/emails/schema.ts - Email schemas co-located with email code
  export const emails = pgTable('emails', { ... });
  export const emailThreads = pgTable('email_threads', { ... });
  
  // apps/api/src/emails/repository.ts - Import from same folder
  import { emails } from './schema';
  ```

## Provider-Agnostic Design

### Normalization Pattern
- **DO**: Define provider-agnostic types in shared package (`Email`, `EmailThread`)
- **DO**: Each provider (Gmail, Outlook) converts their format to the shared types
- **DO**: Store provider-specific data in `metadata` JSONB field
- **DO**: Use `provider` field in emails table (but derive from integration for threads)

### Thread Handling
- **DO**: Group messages by thread during parsing
- **DO**: Create thread records first, then emails
- **DO**: Use upsert pattern for threads to handle updates

## Error Handling

### Validation Errors
- **DO**: Return structured validation errors with field-level details
- **DO**: Log validation failures for debugging
- **Example**:
  ```typescript
  const validationResult = schema.safeParse(data);
  if (!validationResult.success) {
    logger.error({ errors: validationResult.error.errors }, 'Validation failed');
    return c.json({ error: 'Invalid data', details: validationResult.error.errors }, 400);
  }
  ```

## REST API Conventions

### HTTP Methods
- **DO**: Use `DELETE` for all remove/delete operations in REST APIs
- **DO**: Use `POST` for create/add operations
- **DO**: Use `GET` for read/retrieve operations
- **DO**: Use `PUT` or `PATCH` for update operations
- **DON'T**: Use `POST` for remove operations - always use `DELETE`
- **Example**:
  ```typescript
  // ✅ Correct
  app.delete('/labels/remove', async (c) => { ... });
  app.post('/labels/add', async (c) => { ... });
  
  // ❌ Wrong
  app.post('/labels/remove', async (c) => { ... }); // Should be DELETE
  ```
- **Rationale**: Follows REST conventions and makes API intent clear. DELETE semantically indicates removal operations.

## Migration Files

### SQL File Naming
- **DO**: Use descriptive names: `email_threads.sql`, `emails.sql`
- **DON'T**: Use temporary names like `emails_refactored.sql` - rename to final name
- **DO**: Update README.md when renaming files

### Execution Order
- **DO**: Document execution order in README.md
- **DO**: Include dependencies in documentation
- **Example**: `email_threads` → `emails` → (emails depends on threads)

## TypeScript Best Practices

### Type Exports
- **DO**: Export types explicitly: `export type { Email }`
- **DO**: Use `z.infer<typeof schema>` for Zod-derived types
- **DO**: Re-export types from database package in API-specific schemas

### Imports
- **DO**: Import from API-specific schema files in API code
- **DON'T**: Directly import from `@crm/database` in API code
- **Rationale**: Maintains control over what's exposed

## Testing Considerations

### Validation Testing
- **DO**: Test Zod schema validation with invalid data
- **DO**: Test date coercion (ISO strings vs Date objects)
- **DO**: Test required vs optional fields

## Command Execution

### ⚠️ CRITICAL: Always Use Timeouts for ALL Commands
**This rule MUST be applied to EVERY command execution - no exceptions.**

- **DO**: ALWAYS wrap ALL commands (especially long-running ones) with timeout mechanisms to prevent infinite hangs
- **DO**: Use the sleep + kill pattern for macOS compatibility (since `timeout` command may not be available)
- **DO**: Use background processes with PID tracking and cleanup
- **Example Pattern**:
  ```bash
  (command 2>&1 & PID=$!; sleep 30; kill $PID 2>/dev/null; wait $PID 2>/dev/null) || true | tail -10
  ```
- **DO**: For Docker commands, use `docker run -d` with `sleep` and `docker stop` for cleanup
- **DO**: Set appropriate sleep durations based on expected command runtime (e.g., 20-30s for builds, 5-10s for quick checks)
- **DO**: For simple commands that should complete quickly, still use timeouts (e.g., 5-10 seconds)
- **DON'T**: Run ANY command without timeout protection - they can hang indefinitely
- **DON'T**: Use `timeout` command directly (not available on macOS by default)
- **DON'T**: Skip timeout protection even for "quick" commands - always wrap them
- **Rationale**: Prevents getting stuck waiting for commands that hang, especially important for Docker builds, tests, and long-running processes. This is a CRITICAL rule that must be followed for every single command execution.

## Common Mistakes to Avoid

1. ❌ **CRITICAL**: Running commands without timeout protection (can hang indefinitely) - ALWAYS wrap commands with timeout
2. ❌ Putting conversion utilities in `packages/shared`
3. ❌ Exposing all database schemas to all apps
4. ❌ Using verbose type names when simpler names work
5. ❌ Storing redundant data (e.g., provider when integration_id exists)
6. ❌ Using snake_case for TypeScript file names
7. ❌ Not validating API inputs with Zod
8. ❌ Creating temporary file names instead of final names
9. ❌ Using `POST` for remove operations - always use `DELETE` for REST APIs

## Summary Checklist

### ⚠️ CRITICAL: Before Running ANY Command
- [ ] **MANDATORY**: Is the command wrapped with timeout protection? (NO EXCEPTIONS)
- [ ] Is cleanup handled (docker stop, kill PID, etc.)?
- [ ] Is the timeout duration appropriate for the command?

When adding new features:
- [ ] Are conversion utilities in the right package (API, not shared)?
- [ ] Are schemas properly scoped (API-specific exports)?
- [ ] Are types named simply and clearly?
- [ ] Is validation added at API boundaries?
- [ ] Are file names using kebab-case?
- [ ] Is there any redundant data storage?
- [ ] Are foreign keys and constraints properly defined?
- [ ] Is the SQL migration file named correctly?
- [ ] Are remove/delete operations using `DELETE` HTTP method?
